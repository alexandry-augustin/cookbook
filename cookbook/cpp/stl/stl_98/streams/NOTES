iostream
	streambuf
		rdbuf()
		ostream::tellp istream::tellg ostream::seekp istream::seekg (not part of std::streambuf)
		width()
	flush()

	format flags: std::ios_base::fmtflags (bitmask type)
		setf()/unsetf()/flags()

	format accessors:
		width()/precision()/fill()

	state flags:
		goodbit	good()				(= eofbit && failbit && badbit)
		eofbit	eof()				(end of stream reached)
		failbit	fail()/operator!()/operator*()	(an operation has failed)
		badbit	bad()				(loss of integrity: memory shortage, ...)
		clear()/setstate()/rdstate()

	exception flags: (1 for each state flag)
		exception(ios_base::badbit | ios_base::failbit)

	gcount()	number of character extracted from previous operation

	unformatted i/o:
		get()		read a single character
		read()		read a specified number of characters
		getline()	read until '\n'

		put()		write a single character
		write()		write a specified number of characters
==========================================================
std::getline() ???
==========================================================
<ios>
<istream>
<ostream>
<streambuf>
<iosfwd> 

<iostream>
<fstream>
<sstream>
<iomanip> 
	setw()


streambuf filebuf stringbuf
streambuf==dequeue?
cannot directly make random access random reads or writes in a stream.
you can seek to a position in a stream and perform a read at that point.

get / put pointers
seekg() / seekp()
tellg() / tellp()

seekg(0); seekg(0, ios::beg);	//sets the get pointer to the beginning.
seekg(5, ios::beg);		//sets the get pointer to 5 chars forward of the beginning.
tellp(); tellg()		//returns the current value of the put/get pointer
seekp(-10, ios::end);		//sets the put pointer to 10 chars before the end
seekp(1, ios::cur);		//proceeds to next char
==========================================================
seekg(): for reading
seekp(): for writting

std::streampos tellg();
std::streampos tellp();

istream& seekg(streampos position);
istream& seekg(streamoff offset, ios_base::seekdir direction);
	ios_base::beg (offset from the beginning of the stream's buffer)
	ios_base::cur (offset from the current position in the stream's buffer)
	ios_base::end (offset from the end of the stream's buffer)
==========================================================
ios (typedef basic_ios<char> ios):
	rdbuf()
	tie()
	imbue()
	copyfmt()
	narrow()
	widen()
	clear()
	fill()
	flags()
	precision()
	rdstate()
	setf()
	unsetf()
	width()
	good()
	eof()
	bad()
	fail()
	exceptions()
	operator!()
	operator void*()
	setstate()
	manipulator:
		resetiosflags()
		setiosflags()
		setprecision()
		setbase()
		setfill()
		setw()
istream:
	gcount()
	get()
	getline()
	ignore()
	peek()
	putback()
	read()
	readsome()
	seekg()
	sync()
	tellg()
	unget()
	manipulator:
		ws
ostream:
	flush()
	put()
	write()
	tellp()
	seekp()
	manipulator:
		endl()
		ends()
		flush()
ifstream:
	rdbuf()
	is_open()
	open()
	close()
ofstream:
	rdbuf()
	is_open()
	open()
	close()
fstream:
	rdbuf()
	is_open()
	open()
	close()
istringstream:
	rdbuf()
	str()
ostringstream:
	rdbuf()
	str()
stringstream:
	rdbuf()
	str()
