= `main`

== Signatures

[,Gemini]
____
The two function signatures for `main`:

[,c]
----
int main(int argc, char* argv[])
----

and

[,c]
----
int main(int argc, char const * const argv[]) 
----

are almost identical in functionality, but they differ in the const-correctness applied to the command-line arguments array:

`char* argv[]` (Less strict)::
* This is the traditional and most commonly seen form.
* It represents an array of pointers to characters.
* You cannot change the content of the strings (the arguments themselves), as they are typically read-only memory, but the compiler doesn't strictly enforce this through the signature.
* You can change the pointers within the array (e.g., `argv[0] = some_other_string;`), although this is rarely useful or done.
`char const * const argv[]` (More strict/Const-Correct)::
* This is the preferred form in modern C++ because it provides stronger type safety.
* It reads: "an array of `const` pointers (`const argv[]`) to `const` characters (`char const *`)".
* First `const` (`char const *`): You cannot modify the content of the strings (the characters). The compiler will generate an error if you try, e.g., `argv[1][0] = 'a';`. This reflects the reality that command-line arguments are usually read-only.
* Second `const` (`const argv[]`): You cannot modify the pointers within the array. The compiler will generate an error if you try, e.g., `argv[0] = some_other_string;`.

In essence, the `char const * const argv[]` signature explicitly tells the compiler and other programmers that neither the argument strings nor the array of pointers should be modified.

For a typical program that only reads the command-line arguments, there is no functional difference in how the program executes.

However, from a software engineering perspective:

* The `char const * const argv[]` version is safer and better because it enforces that the arguments are treated as immutable (read-only) data, which aligns with their intended use.

* In C++, the `char const * const argv[]` form is often considered the best practice as it aligns with the principle of const-correctness.
____

[,Gemini]
____
For a C program, you should generally use the traditional and most common form:

[,c]
----
int main(int argc, char* argv[])
----

*\1. Standard and Portability*
The signature `int main(int argc, char* argv[])` is the **standard definition** for `main` specified by the C standard (C99, C11, C18). It is universally recognized and supported by all C compilers.

*\2. Practicality*

In C, the primary use case for command-line arguments is simply to **read** them. While the standard does not explicitly prohibit modifying the strings pointed to by `argv`, doing so leads to **undefined behavior** because those strings are typically stored in a read-only area of memory.

*\3. Compatibility*

Many C functions and libraries that process strings expect a `char*` pointer for a non-`const` string. While you can cast or use the `const` version, sticking to the standard signature simplifies interactions with older C code and libraries.

*Note on Const-Correctness*

The more strict signature, `int main(int argc, char const * const argv[])`, is primarily a **C++ best practice**. It is technically valid in C and provides better type safety by explicitly preventing you from trying to change the pointers in the `argv` array or the characters in the argument strings, but it is **not the canonical form** for C.

**Conclusion:** Stick with the simplest, most common, and standard C form: **`int main(int argc, char* argv[])`**.
____

[,ChatGPT]
____
Most C codebases (including the C standard examples) use:

[,c]
----
int main(int argc, char* argv[])
----

because it's conventional, clear, and universally accepted.

But if you're writing modern, const-correct C code and want to enforce immutability, the `const` version is absolutely fine -- and arguably better.
____

== Arguments

[,c]
----
printf("%d %s\n", argc, argv[1]);
----