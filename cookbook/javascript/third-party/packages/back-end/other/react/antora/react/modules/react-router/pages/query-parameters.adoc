= Query Parameters

[,Gemini]
____
In React Router v7, you don't need to change the Route component to handle query parameters.

The `Route` component in React Router is primarily used to match the path of a URL. Query parameters, which appear after the `?` in a URL (e.g., `/products?category=electronics`), are not considered part of the path for routing purposes. Therefore, React Router's path matching mechanism ignores them.

This design allows for greater flexibility, as the same route can handle multiple variations of query parameters without needing a separate route definition for each one.
____

== Page Component

Retrieve query parameters: 

[,tsx]
----
import { useSearchParams } from 'react-router';

function MyPage() {
  const [searchParams, setSearchParams] = useSearchParams();

  // Get a specific query parameter
  const my_param1 = searchParams.get('my_param1');

  // Set a new query parameter
  const handleSortChange = (newSort) => {
    setSearchParams({ ...Object.fromEntries(searchParams), sort: newSort });
  };

  return (...);
}
----

=== Enforcing Query Parameters

[,Gemini]
____
There isn't a built-in mechanism in React Router to *enforce* query parameters in the same way you enforce path parameters. However, you can achieve this by checking for the presence of the required query parameters within your component and then redirecting or displaying an error message if they're missing.

The most common approach is to use the **`useSearchParams`** hook from React Router to read the query parameters and then use the **`useNavigate`** hook to redirect the user if a required parameter isn't present.

Here's a step-by-step example:

1.  **Read the query parameters**: Use `useSearchParams` to get the current search params object.
2.  **Check for required parameters**: Check if the necessary key-value pairs exist.
3.  **Redirect if missing**: If a required parameter is missing, use `useNavigate` to redirect the user to a different page, like an error page, or a page where they can properly set the parameters.

*Example Implementation*

Let's say you have a `ProductDetails` page that *requires* a `productId` query parameter.

[,jsx]
----
import React, { useEffect } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';

function ProductDetails() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();

  const productId = searchParams.get('productId');

  useEffect(() => {
    // Check if the productId is missing or is not a valid ID
    if (!productId) {
      // Redirect to a "not found" or "error" page
      // Or you could redirect to the products list page
      navigate('/products', { replace: true });
    }
  }, [productId, navigate]);

  if (!productId) {
    // This is a failsafe. The redirect in useEffect should handle this,
    // but this prevents rendering until the redirect happens.
    return null;
  }

  // If productId exists, render the component content
  return (
    <div>
      <h1>Product Details for ID: {productId}</h1>
      <p>This page requires a product ID to display correctly.</p>
    </div>
  );
}

export default ProductDetails;
----

In this example, the `useEffect` hook runs whenever `productId` or `Maps` changes. If `!productId` is true, the `Maps` function redirects the user away from the page, preventing it from rendering in an incomplete state. The `{ replace: true }` option is often used to prevent the user from being able to navigate back to the invalid URL using the browser's back button.

This approach gives you fine-grained control over how to handle missing data and provides a more robust user experience.
____

== Navigation Component

Add query parameters to a navigation: 

[,tsx]
----
import { useNavigate, createSearchParams } from 'react-router-dom';

function MyComponent() {
  const navigate = useNavigate();

  const params = {
    q: query,
    page: 1,
    sort: 'relevance'
  };

  navigate({
    pathname: '/results',
    search: createSearchParams(params).toString()
  });

  return (...);
}
----

== Adding a Single Query Parameters

[,tsx,title="useAddQueryParam.tsx"]
----
import { useSearchParams } from 'react-router-dom';

export const useAddQueryParam = () => {
  const [searchParams, setSearchParams] = useSearchParams();

  const addQueryParam = (key, value) => {
    // Create a new URLSearchParams object from the current one to preserve existing params
    const newSearchParams = new URLSearchParams(searchParams);
    
    // Set or update the new query parameter
    newSearchParams.set(key, value);
    
    // Update the URL with the new search parameters
    setSearchParams(newSearchParams);
  };

  return { searchParams, addQueryParam };
};
----

[,tsx,title="MyComponent.tsx"]
----
import { useAddQueryParam } from './useAddQueryParam';

function MyComponent() {
  // Use the custom hook to get the search params and the update function
  const { searchParams, addQueryParam } = useAddQueryParam();

  const handleAddParam = () => {
    addQueryParam('paramName', 'paramValue');
  };

  return (...);
}
----

== Centralised Query Parameters Management

[,Gemini]
____
In a React application, it's generally a good practice to have a common, centralized function or hook in charge of updating query parameters.

The most idiomatic React way to centralize this logic is by creating a custom hook, often named something like `useQueryParams` or `useUrlState`.

*Example Concept*

[,ts,title="useQueryParams.ts"]
----
import { useSearchParams } from 'react-router';

export function useQueryParams() {
  const [searchParams, setSearchParams] = useSearchParams();

  const updateParams = (newParams) => {
    // 1. Get the current params
    const currentParams = Object.fromEntries(searchParams.entries());

    // 2. Merge with the new params
    const mergedParams = { ...currentParams, ...newParams };

    // 3. Filter out null/undefined/empty string values if desired
    const cleanedParams = Object.entries(mergedParams).reduce((acc, [key, value]) => {
      if (value) { // simple check to omit empty values
        acc[key] = value;
      }
      return acc;
    }, {});

    // 4. Update the URL
    setSearchParams(cleanedParams);
  };

  return [Object.fromEntries(searchParams.entries()), updateParams];
}
----

The returned value from this custom hook or function is an array containing two elements:

* An object representing the current URL search parameters like `{ key1: 'value1', key2: 'value2' }`
* A function to update those search parameters.

Component Usage:

[,tsx,title="MyComponent.tsx"]
----
import { useQueryParams } from './useQueryParams';

function MyComponent() {
  const [searchParams, updateParams] = useQueryParams();

  updateParams({ key1: 'value1' });
  // updateParams(new URLSearchParams({ key1: 'value1' })); ???
  const key1 = searchParams.key1 || 'default';

  return (...);
}
----
____

[comment]
--
[,ts,title="useAddQueryParam.ts"]
----
import { useSearchParams } from 'react-router';

export const useAddQueryParam = () => {
  const [searchParams, setSearchParams] = useSearchParams();

  const addQueryParam = (key, value) => {
    // Create a new URLSearchParams object from the current one to preserve existing params
    const newSearchParams = new URLSearchParams(searchParams);
    
    // Set or update the new query parameter
    newSearchParams.set(key, value);
    
    // Update the URL with the new search parameters
    setSearchParams(newSearchParams);
  };

  return { searchParams, setSearchParams, addQueryParam };
};
----
--