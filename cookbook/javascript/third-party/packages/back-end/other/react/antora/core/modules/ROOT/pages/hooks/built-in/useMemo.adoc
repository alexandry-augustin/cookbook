= `useMemo`

[,Gemini]
____
From a functional perspective, the code [with and without useMemo] would behave the same. 
`useMemo` is strictly a performance optimization; it does not change the logic or the output of the function it wraps.

The value returned by `useMemo` will be the exact same value that the function would return if it were called directly on every render. 
The only difference is that with `useMemo`, the function is **memoized**, meaning it's not re-executed unless its dependencies change.

Consider the following two examples:

[,javascript,title="With useMemo"]
----
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
----

[,javascript,title="Without useMemo"]
----
const memoizedValue = computeExpensiveValue(a, b);
----

In both cases, `memoizedValue` will hold the result of `computeExpensiveValue(a, b)`. 
The only practical difference is **when** that computation happens. 
The `useMemo` version will skip the calculation on subsequent renders if `a` and `b` haven't changed, while the version without it will re-run the function on **every single render**, regardless of whether the inputs have changed.
____