= Conventions

== Data Fetching

[,Gemini]
____
When using React Router v7, the recommended approach is for the **page component to fetch its data**.
This approach centralizes data logic and is often called "lifting state up".

*Data Fetching with React Router v7*

In React Router v7, the concept of **route loaders** is the preferred method for fetching data. This shifts the responsibility of data fetching from individual components to the route definition itself.

*How it Works*

Route Loader:: You define a `loader` function on your route object. This function is an asynchronous function that fetches the data needed for the page.
Data Awaited:: Before the component is rendered, the `loader` function is called and the router waits for the data to be fetched. This prevents a "loading" state flash on the client.
Accessing Data:: Once the data is loaded, you can access it in your page component using the `useLoaderData` hook.

*Why this is the Better Approach*

Improved Performance:: The data is fetched in parallel with the code for the next page, leading to faster initial rendering.
Simplified Component Logic:: Your components don't need to manage loading states, error handling, or fetching logic. They just receive the data they need and render it.
Better User Experience:: No more "waterfall" of data requests. The data is ready before the page even appears.
Declarative Data Dependencies:: The route definition clearly states what data is required for that page, making your application's data flow more explicit and easier to understand.
Server-Side Rendering (SSR) & Pre-fetching:: This pattern works seamlessly with SSR and enables React Router to pre-fetch data for a link when a user hovers over it, making navigation feel instantaneous. 

In short, while you could technically have each component fetch its own data, it's less efficient and can lead to a more complex component hierarchy. The `loader` pattern in React Router v7 is designed to solve these problems and provides a more robust and performant way to manage data dependencies.
____

== Imports

....
src/
├── components/
│   ├── MyGenericFeature
│   │   ├── MyFirstGenericFeatureComponent.tsx
│   │   └── MySecondGenericFeatureComponent.tsx
│   └── MyGenericComponent.tsx
│
├── pages/
│   ├── MyPage/
│   │   ├── components
│   │   │   ├── MyFeature
│   │   │   │   ├── MyFirstFeatureComponent.tsx
│   │   │   │   └── MySecondFeatureComponent.tsx
│   │   │   ├── MyComponent.tsx
│   │   └── MyPage.tsx
│   └── ...
└── ...
....

[,Prompt]
____
in react i have the following file structure: 

...

how should the all of theses components references each other, that is, in which cases should relative paths be used and in which cases absolute paths be used 
____


// [,Gemini]
// _____
// For generic components located in the `src/components/` directory, you should use absolute paths when importing them into `MyPage.tsx`.
// 
// Why Absolute Paths?
// 
// Using absolute paths simplifies imports and makes your code more maintainable, especially as your project grows. 
// Instead of navigating up the directory tree with multiple `../`, you can import a component directly from a consistent, project-level reference point.
// 
// [,javascript]
// ----
// import Button from 'components/Button';
// ----
// 
// This works because most modern React project setups (like those created with Create React App or Next.js) automatically configure a "path alias" for the `src` directory. 
// This allows you to treat `src` as the root for imports, so `src/components/Button.tsx` becomes `components/Button`.
// 
// Why Not Relative Paths?
// 
// Using a relative path for a generic component in `src/components/` would look like this:
// 
// [,javascript]
// ----
// import Button from '../../components/Button';
// ----
// 
// While this works, it's problematic for a few reasons:
// 
// Fragile and Prone to Errors:: If you move `MyPage.tsx` to a different subdirectory, you would have to manually update the number of `../` to point to the correct location. 
// This can lead to bugs and is a common source of developer frustration.
// Less Readable:: Long strings of `../../` make the code harder to read and understand at a glance, obscuring where the component is actually coming from.
// Scalability Issues:: In a large application with many nested directories, relative paths can become unwieldy and confusing.
// 
// Using absolute paths for shared components is a best practice that leads to cleaner, more robust, and easier-to-maintain code.
// _____
// 
// 
// [,Gemini]
// _____
// You should use absolute paths when importing a generic component from the `src/components/` directory into another generic component within the same directory. 
// This is consistent with the best practice for importing generic components throughout your application.
// _____
// 

== Hooks

[,Gemini]
____
// > in react, where should i place hooks files that are only used in a single page
here's a general guideline for organizing hooks:

Single-use hooks:: Place them in the same directory as the component that uses them.
Shared hooks:: If a hook is used by multiple components, place it in a shared hooks directory at the root of your src folder (e.g., `src/hooks/`). 
This makes it clear that the hook is available for global use.
____