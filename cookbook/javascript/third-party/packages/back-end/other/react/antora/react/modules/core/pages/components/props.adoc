= Props

Props are like attributes in HTML.

See "Prop Drilling".

[,jsx]
----
function ParentComponent() {
    return (
        <>
            <ChildComponent prop_name={ prop_value } />
        </>
    )
}

function ChildComponent({ prop_name }) {
    return (
        <>{ prop_name }</>
    )
}

// Or

function ChildComponent(props) {
    return (
        <>{ props.prop_name }</>
    )
}
----

[comment]
--
[,tsx,title="Parent.tsx"]
----
import Button from './Child.tsx';

export default function App() {
    return (
        <>
            <Child bkg_colour="white" text="Text" onClick={ handlerFct }/>
        </>
    );
}
----

[,tsx,title="Child.tsx"]
----

export default function Child(props) {
    return (
        <div  
            style={{ backgroundColor: props.bkg_colour }} 
            onClick={ props.handlerFct } >
            { props.text }
        </div>
    );
}
----
--

== Default Values

[,jsx]
----
function MyComponent({ prop_name="default_value" }) {
    return (
        <>{ prop_name }</>
    )
}
----

=== `defaultProps` [DEPRECATED]

https://sophiabits.com/blog/stop-using-defaultprops[Stop using `defaultProps`!]

[,jsx]
----
default export function MyComponent(props) {
    return (
        <>{ props.id }</>
    )
}

MyComponent.defaultProps = {
    id: "123"
};
----

== `{...props}`

[,Gemini]
____
Using `{...props}` is an excellent and more flexible way to handle props in a reusable React component. 
It's a common pattern that allows you to pass down any and all props from the parent component to the child component without explicitly naming each one.

The object containing a component's properties can be called something other than `props`. 
While `props` is the standard and widely accepted convention, it's not a technical requirement.

.Why this Approach is Better
Flexibility:: You don't have to explicitly destructure every possible prop. This makes the component more adaptable to different use cases. You can now pass `id`, `name`, `onFocus`, `onBlur`, and any other valid HTML attribute directly.
Conciseness:: The code is cleaner and shorter. You don't need to write `className={props.className}` and `placeholder={props.placeholder}` individually.
Scalability:: If you need to add a new attribute to your input field in the future, you don't have to modify the `InputField` component itself. You simply pass the new prop from the parent component.

This pattern is a fundamental part of building truly reusable and extensible React components. It's often combined with destructuring to explicitly handle props that are specific to your component's logic, while passing all other standard HTML attributes down using `{...props}`.
____

=== Examples

==== Default Props

NOTE: If a prop is defined multiple times, the last one takes precedence.

[,tsx]
----
const InputField = (props) => {
  return (
    <input
      type="text" // Default prop
      {...props}
    />
  );
};

function App() {
  return (
    <InputField
        // Overrides the default value
        type="search" 

        className="..."
        placeholder="..."
        id="..."
        onChange={...}
    />
  );
}
----

==== Props Filtering

Selectively pass props by destructuring it from the props object before using the rest of the props with the spread operator:

[,tsx]
----
const InputField = (props) => {
  return (
    <input
      type="text"
      {...props}
    />
  );
};

const InputFormField = (props) => {
  // Prevent the "label" prop from being passed as a prop to the <input> element
  const { label, ...rest } = props;

  return (
    <label>{label}</label>
    <input
      {...rest}
    />
  );
};

function App() {
  return (
    <InputFormField
        label="label"

        type="search"
        className="..."
        placeholder="..."
        id="..."
        onChange={...}
    />
  );
}
----

Selectively pass props destructuring all the props and then construct a new object that contains only the props you want to pass down: 

[NOTE]
====
[,Gemini]
____
This provides a stronger guarantee about the component's behavior.

.Why You Might Choose This Method
Stricter Control:: This approach gives you complete control over which props are consumed by the child component. If a new developer adds an unknown prop, it won't affect the input's behavior.
API Enforcement:: It helps you enforce a specific API for your component. It makes it clear to other developers what props are supported and what they are used for.
Prevents DOM Clutter:: It avoids passing non-standard or unused props to the underlying HTML element, keeping the DOM clean and free of unnecessary attributes.

This method is a valid alternative to the rest operator, particularly when you need to be very prescriptive about your component's public interface. However, for a general-purpose component that should support all standard HTML attributes, the rest operator (`...rest`) is often the preferred and more flexible solution.
____

[,Gemini]
____
For an input element, **using the rest operator (`...rest`) is generally the recommended and most flexible approach.**

This method provides a balance between control and reusability that is perfect for a generic component like an input.

*Why `...rest` is Recommended*

Flexibility:: An `<input>` element has many standard HTML attributes (`onChange`, `onBlur`, `name`, `id`, `value`, `type`, etc.). Explicitly defining every single one as a prop would be tedious and make your component's API rigid. Using `...rest` allows you to pass any valid HTML attribute from the parent component without having to modify the child component's code.
Reusability:: The primary goal of abstracting a component is to make it reusable. With `...rest`, your `Input` component becomes a highly adaptable building block that can be used for text fields, password fields, search bars, and more, all while remaining a single, clean component.
Clear Intent:: When you destructure specific props like `label` and then spread the `...rest` on the underlying HTML element, you are being very explicit. You're saying, "This component handles the `label` prop specifically, and all other props are intended for the `<input>` element itself." This makes your code easy to understand and maintain. 

*When to be More Selective*

There are times when a more selective approach is better, such as:

Wrapper Components:: If you're building a more complex component that **wraps** an input and adds its own logic (e.g., a "ValidatedInput" that takes a `validationRule` prop), you might want to be more selective to ensure that only the correct props are passed down and to prevent developers from accidentally overriding your internal logic.
Preventing Prop Collisions:: If you have props with the same name that are meant for different purposes (e.g., a `style` prop for the wrapper `div` and another `style` prop for the `<input>`), being selective helps you avoid collisions.

For a simple, abstracted input component, however, the `...rest` pattern is the standard, most practical, and highly recommended best practice in React.
____
====

[,tsx]
----
const InputField = (props) => {
  return (
    <input
      type="text"
      {...props}
    />
  );
};

const InputFormField = (props) => {
  const { id, label, className, placeholder } = props;

  // Ensures that no other props, like onChange, onFocus, or style, will ever reach the <input> element. 
  const inputProps = {
    id: id,
    type: type, 
    className: className,
    placeholder: placeholder,
  };

  return (
    <>
      <label>{label}</label>
      <input
        {...inputProps}
      />
    </>
  );
};

function App() {
  return (
    <InputFormField
        label="label"

        type="search"
        className="..."
        placeholder="..."
        id="..."
        onChange={...}
    />
  );
}
----
