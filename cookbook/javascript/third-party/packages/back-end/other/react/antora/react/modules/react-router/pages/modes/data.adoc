= Data

== Installation

[,bash]
----
pnpm install react-router
----

[,tsx,title='src/main.tsx']
----
import React from 'react';
import ReactDOM from 'react-dom/client';
import { RouterProvider } from 'react-router/dom';

import router from '@/router';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>,
);
----

[,tsx,title='src/router.tsx']
----
import { createBrowserRouter } from "react-router";

const router = createBrowserRouter([
  {
    path: "/",
    children: [
      {
        index: true,
        element: <>Home</>,
      },
      {
        path: "about",
        element: <>About</>,
      },
    ],
  },
]);

export default router;
----

== Example

[,tsx,title='src/router.tsx']
----
import { createBrowserRouter } from "react-router";

import App from '@/App';
import HomePage from '@/pages/HomePage';
import AboutPage from '@/pages/AboutPage';
import { postsLoader } from '@/postsLoader';

const router = createBrowserRouter([
  {
    path: "/",
    element: <App />,
    children: [
      {
        index: true,
        element: <HomePage />,
      },
      {
        path: "about",
        element: <AboutPage />,
      },
      {
        path: "posts",
        element: <div>Posts</div>,
        loader: postsLoader,
      }
    ],
  },
]);

export default router;
----

[,tsx,title='src/App.tsx']
----
import { Outlet } from "react-router";

function App() {
  return (
    <div>
      <header>
        <nav>{/* ... */}</nav>
      </header>
      
      <main>
        {/* The <Outlet> renders the current nested route's component */}
        <Outlet />
      </main>

      <footer>{/* ... */}</footer>
    </div>
  );
}

export default App;
----

[,ts,title='src/postsLoader.ts']
----
export async function postsLoader() {
  const response = await fetch("https://api.example.com/posts");
  if (!response.ok) {
    throw new Error("Failed to fetch posts");
  }
  const posts = await response.json();
  return posts;
}
----

[,tsx,title='src/components/Posts.tsx']
----
import { useLoaderData } from "react-router";

export default function Posts() {
  const posts = useLoaderData();

  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}
----


== `loaders`

[,Gemini]
____
When a component uses `useLoader` Data, it doesn't need to manage loading states (`isLoading`, `isError`) or `useEffect` dependencies. Its sole purpose becomes to render the data it receives, making the component code cleaner and more focused on the UI.
____

== `actions`

[,Gemini]
____
Actions are functions that handle data mutations, such as form submissions. 
They provide a standardized way to handle data-driven events directly within your route definitions, separating data logic from your UI components. 

When a `<Form>` component is submitted, React Router intercepts the request and calls the `action` function associated with the current route. 
The function then handles the data and can perform operations like updating a database, making an API call, or redirecting the user to a different page.

*Key Features and Benefits*

Server-Side and Client-Side Handling:: Actions can be defined as either `action` (for server-side execution) or `clientAction` (for browser-only execution). This allows for flexible architecture, where server actions are removed from client bundles, reducing overall bundle size. Client actions take precedence if both are defined.
Automatic Revalidation:: After an action completes, React Router **automatically revalidates** all the loader data on the page. This ensures that the UI stays in sync with the latest data without you having to write additional code to fetch and update the state.
Improved Form Handling:: Actions streamline form handling by providing a declarative, centralized way to manage form submissions and data mutations. You no longer need to rely solely on `useState` and `useEffect` for these tasks, leading to cleaner, more maintainable code.
Built-in APIs:: React Router provides hooks like `useActionData` to access the data returned by an action and `useNavigation` to track the state of a form submission (e.g., "submitting", "idle") which allows you to build sophisticated UIs with loading states and optimistic updates. 
____