= Async Uploads

[,Gemini]
____
The process of submitting the form data in two separate calls:

. `POST /api/uploads/images` (for images)
. `POST /api/products` (for the resource data, including the image IDs/URLs)

-- is often called *Pre-Uploading* or *Asynchronous Uploads*.

*Benefits of the Two-Call Approach*

|===
| Benefit | Description

| *Improved User Experience (UX)*
| The user can receive *instant feedback* that their image has uploaded while they are still filling out other form fields. It also prevents the entire form submission from failing just because of a temporary network hiccup during the image upload.

| *Decoupling and Scalability*
| *Image uploads are resource-intensive* (handling large binary data, resizing, saving to storage). Decoupling them allows you to send those requests to a *dedicated microservice* or a service like *AWS S3* or *Google Cloud Storage* directly, offloading the main application server.

| *Reliability and Atomicity*
| If the main form submission (`/api/products`) fails, the image is already uploaded and validated. The client can simply retry the text submission, or you can manage cleanup logic for orphaned images later. The text submission is much faster and less prone to timeout errors.

| *Flexibility*
| The `/api/uploads/images` endpoint can be used by *any part of your application* (user profile, comments, product creation, etc.) without needing custom logic for each resource type.

| *Better Network Performance*
| You can use *optimistic loading* (showing a preview of the image immediately) because the image file is already processing on the server before the user even hits "Submit" on the main form.
|===

*Recommended Workflow*

Here's the typical workflow when using this two-call pattern:

. *Client Action:* A user drags/drops or selects an image file.
. Client Call 1 (Image Upload): The front-end immediately sends a POST request with the image file to:
+
POST /api/uploads/images

. Server Response 1: The server processes the image, saves it to storage, and responds with a reference (e.g., a URL, a unique ID, or a file path):
+
{"image_id": "a9b1c2d3", "url": "/storage/product/a9b1c2d3.jpg"}

. *Client Updates Form:* The front-end receives the ID/URL and *populates a hidden field* in the main product form with this value (e.g., `image_id: "a9b1c2d3"`).
. Client Call 2 (Main Submission): When the user clicks "Submit," the front-end sends a separate, much smaller POST request to the main resource endpoint:
+
POST /api/products
+
JSON Body: {"name": "New Gadget", "description": "...", "price": 99.99, "image_id": "a9b1c2d3" }

. *Server Finalizes:* The product server receives the text data and the `image_id`, then *links* that existing image record (from Step 3) to the new product record in the database.
____