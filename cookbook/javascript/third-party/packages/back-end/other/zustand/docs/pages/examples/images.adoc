= Images

// Storing images retrieved with `react-dropzone` in a zustand store before submission.

[,Gemini]
____
The best way to handle images from React Dropzone in a Zustand store before submission is to store a **serializable representation** of the image, such as a **Base64 string** or a **Temporary Object URL**.

Storing the raw `File` object is generally discouraged because it's not serializable, which causes problems if you use Zustand's `persist` middleware or browser devtools.

Here's how to implement it using a **Temporary Object URL**, which is efficient for previews and cleanup:

*Define Your Zustand Store*

We'll store an array of image objects. Each object will contain the original `File` (which you'll need for submission) and the temporary URL for immediate preview.

[,javascript]
----
import { create } from 'zustand';

// Define the type for an image object
export interface StoredImage {
  file: File;
  preview: string; // The temporary Object URL for <img src>
}

interface ImageStore {
  images: StoredImage[];
  addImages: (files: File[]) => void;
  clearImages: () => void;
  // Note: We'll add a function to get the files for submission later
}

export const useImageStore = create<ImageStore>((set, get) => ({
  images: [],

  addImages: (newFiles) => {
    const newStoredImages: StoredImage[] = newFiles.map(file => ({
      file: file,
      // Create a temporary URL for the preview
      preview: URL.createObjectURL(file), 
    }));

    set((state) => ({
      images: [...state.images, ...newStoredImages],
    }));
  },

  clearImages: () => {
    // CRITICAL: Revoke the object URLs to prevent memory leaks
    get().images.forEach((img: StoredImage) => URL.revokeObjectURL(img.preview));
    set({ images: [] });
  },
}));
----

*Integrate with React Dropzone*

Use the `addImages` action inside your Dropzone's `onDrop` handler.

[,jsx]
----
import React, { useEffect } from 'react';
import { useDropzone } from 'react-dropzone';
import { useImageStore } from './path/to/useImageStore';

function ImageDropzone() {
  const images = useImageStore(state => state.images);
  const addImages = useImageStore(state => state.addImages);
  const clearImages = useImageStore(state => state.clearImages);

  const onDrop = (acceptedFiles) => {
    // acceptedFiles is an array of File objects from React Dropzone
    addImages(acceptedFiles);
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({ onDrop });

  // Cleanup: This ensures temporary URLs are revoked when the component unmounts
  useEffect(() => {
    return () => {
      // Clean up the temporary URLs when the component is removed from the DOM
      clearImages();
    };
  }, [clearImages]);

  return (
    <div>
      <div {...getRootProps()} className="dropzone-area">
        <input {...getInputProps()} />
        {isDragActive
          ? <p>Drop the files here ...</p>
          : <p>Drag 'n' drop some images here, or click to select files</p>
        }
      </div>

      <div className="previews">
        {images.map((img) => (
          <div key={img.preview}>
            {/* The preview property is the temporary URL */}
            <img 
              src={img.preview} 
              alt={img.file.name} 
              style={{ width: '100px', height: '100px', objectFit: 'cover' }}
            />
            <p>{img.file.name}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
----

*Handle Submission (Uploading the Files)*

When the user clicks "Submit," you'll extract the original `File` objects from the store's state.

[,javascript]
----
// ... inside your submission component
import { useImageStore } from './path/to/useImageStore';

const handleSubmit = (event) => {
  event.preventDefault();

  // Get the array of original File objects from the store
  const filesToSubmit = useImageStore.getState().images.map(img => img.file);

  if (filesToSubmit.length === 0) {
    console.log("No files to upload.");
    return;
  }
  
  // Create FormData object for the API submission
  const formData = new FormData();
  filesToSubmit.forEach((file) => {
    // 'images' should match the field name your server expects
    formData.append('images', file, file.name); 
  });

  // Example: Send the FormData to your API
  // fetch('/api/upload', {
  //   method: 'POST',
  //   body: formData,
  // });
  
  console.log('Submitting files:', filesToSubmit);

  // Clear the store state after submission
  useImageStore.getState().clearImages();
};
----
____

[,Gemini]
____
To prevent duplicate images in your Zustand store based on the string identifier `${image.file.name}-${image.file.size}`, you'll need to update your `addImages` action to check for the existence of this unique identifier before adding a new image.

Here is the updated logic for your `useImageStore`:

*Updated Zustand Store Logic*

The key change is using a **Set of strings** (the unique identifiers) within your store state to perform quick lookups.

[,javascript]
----
import { create } from 'zustand';

export interface StoredImage {
  file: File;
  preview: string;
}

interface ImageStore {
  images: StoredImage[];
  imageIdentifiers: Set<string>; // New: A set to store unique identifiers
  addImages: (files: File[]) => void;
  clearImages: () => void;
}

// Function to generate the unique identifier
const getIdentifier = (file: File): string => 
  `${file.name}-${file.size}`;

export const useImageStore = create<ImageStore>((set, get) => ({
  images: [],
  imageIdentifiers: new Set(), // Initialize the Set

  addImages: (newFiles) => {
    const { images, imageIdentifiers } = get();
    const newStoredImages: StoredImage[] = [];
    const newIdentifiers = new Set(imageIdentifiers); // Create a copy of the existing Set

    newFiles.forEach(file => {
      const identifier = getIdentifier(file);

      // 1. Check if the identifier already exists in the Set
      if (!newIdentifiers.has(identifier)) {
        // 2. If it's a new image, create the StoredImage object
        newStoredImages.push({
          file: file,
          preview: URL.createObjectURL(file),
        });
        
        // 3. Add the new identifier to the Set
        newIdentifiers.add(identifier);
      } else {
        console.warn(`Duplicate file skipped: ${file.name}`);
      }
    });

    if (newStoredImages.length > 0) {
      set({
        // Append new images to the array
        images: [...images, ...newStoredImages], 
        // Update the Set with the new, non-duplicate identifiers
        imageIdentifiers: newIdentifiers, 
      });
    }
  },

  clearImages: () => {
    // CRITICAL: Revoke the object URLs to prevent memory leaks
    get().images.forEach(img => URL.revokeObjectURL(img.preview));
    
    // Reset both the array and the Set
    set({ 
      images: [],
      imageIdentifiers: new Set(),
    });
  },
}));
----

*Explanation of Changes*

`imageIdentifiers: Set<string>`:: A new state property, a JavaScript `Set`, is introduced to hold the unique strings (`${name}-${size}`). A `Set` is used because checking if an item exists (`Set.prototype.has()`) is significantly **faster** than searching through an array, especially as the number of images grows.
`getIdentifier(file)`:: A utility function is used to consistently generate the unique string from a `File` object.
Duplicate Check::
* Inside `addImages`, we iterate over the `newFiles`.
* For each file, we generate its `identifier`.
* We use `!newIdentifiers.has(identifier)` to quickly determine if a file with that exact name and size already exists.
* If it doesn't exist, the image is added to the `newStoredImages` array, and its identifier is added to the `newIdentifiers` Set.
`clearImages` Update:: When clearing the store, you now also reset the `imageIdentifiers` set to a new empty `Set()`.
____

[,Gemini]
____
To prevent duplicate images from being added to your Zustand store, you need to check if a newly dropped file already exists in the `images` array. The most reliable way to do this with files is to compare a unique property, such as the **file name, size, and last modified timestamp**, as files are typically treated as duplicates if all these metadata fields match.

Here's how to update the `addImages` action in your Zustand store to filter out duplicates:

*Update the Zustand Store Logic*

The key change is to create a unique identifier for each file and check against the existing identifiers before adding.

[,javascript]
----
import { create } from 'zustand';

export interface StoredImage {
  file: File;
  preview: string; // Temporary Object URL
}

interface ImageStore {
  images: StoredImage[];
  addImages: (files: File[]) => void;
  clearImages: () => void;
}

// Helper function to create a unique key for a file
const getFileKey = (file: File) => 
  `${file.name}-${file.size}-${file.lastModified}`;

export const useImageStore = create<ImageStore>((set, get) => ({
  images: [],

  addImages: (newFiles) => {
    const currentState = get().images;
    const existingKeys = new Set(currentState.map(img => getFileKey(img.file)));

    const newStoredImages: StoredImage[] = [];
    
    // Process only files that are not already in the store
    newFiles.forEach(file => {
      const fileKey = getFileKey(file);
      
      if (!existingKeys.has(fileKey)) {
        newStoredImages.push({
          file: file,
          preview: URL.createObjectURL(file), 
        });
        // Add the new key to the set to prevent duplicates within the new batch
        existingKeys.add(fileKey); 
      }
    });

    // If any unique new files were found, update the state
    if (newStoredImages.length > 0) {
      set((state) => ({
        images: [...state.images, ...newStoredImages],
      }));
    }
  },

  clearImages: () => {
    get().images.forEach(img => URL.revokeObjectURL(img.preview));
    set({ images: [] });
  },
}));
----

*Summary of the Change*

. A helper function, `getFileKey`, is introduced to generate a **unique string** using the file's **name, size, and last modified timestamp**.
. Inside `addImages`, a `Set` called `existingKeys` is created from all files currently in the store. Using a `Set` is highly efficient for checking for existence.
. The `newFiles` array is iterated, and `getFileKey` is used to check if the file's key is already in `existingKeys`.
. If the key is **not** present, the file is added to the batch of new images and its key is added to `existingKeys` (to prevent duplicates within the same batch).
. Finally, the state is updated only with the unique, new images.
____

[,Gemini]
____
The `fileKey` **should not** be included in your `StoredImage` interface.

*Reasoning*

The purpose of the `fileKey` is purely for **internal logic** within your Zustand store's `addImages` actionâ€”specifically, to efficiently check for and prevent duplicates.

Redundancy:: The components that consume the store (e.g., for display or final submission) only need the `file` itself and the `preview` URL. The `fileKey` is just a concatenation of data already available on the `file` object (`name`, `size`, `lastModified`). Storing it in the state adds unnecessary, redundant data.
Logic Separation:: Keeping the `getFileKey` logic and its use for duplicate checking contained within the `addImages` action makes the store cleaner and separates the **state logic** (how you manage the list) from the **state data** (what you need to use the image).
Efficiency:: As demonstrated, the `fileKey` is only needed transiently:
* To build a `Set` of existing keys.
* To check new files against that `Set`.

The original structure, where `getFileKey` is a helper function used only within the store's action, is the best practice.
____

[,Gemini]
____
The `fileKey` **should not** be part of your `ImageStore`'s state (i.e., it shouldn't be a top-level property of the store).

The `fileKey` is a **transient tool** used only within the store's action (`addImages`) for duplicate-checking logic. It's not a piece of data that your components need to render or use for submission.

*Why the Current Implementation is Best*

Your existing structure, where `getFileKey` is a helper function used *inside* the `addImages` action, is the best practice because:

Readability and Intent:: The store's state (`images`) clearly represents the data needed by the application. Adding an internal utility property like `fileKey` to the state would clutter it.
Avoid Redundancy:: The key is derived directly from properties already on the `File` object (`name`, `size`, `lastModified`). Storing the keys globally would be redundant.
Efficiency:: The keys are only needed when running the `addImages` function to create the `existingKeys` set. Storing the entire set of keys on the main store state would be less efficient than generating them inside the action, where they are immediately used and then discarded.
____