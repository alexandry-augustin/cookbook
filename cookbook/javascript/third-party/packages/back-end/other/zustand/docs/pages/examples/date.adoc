= `Date` Object

[,javascript,title="useDateTimeStore.ts"]
----
import { create } from 'zustand';

// We store the datetime as a string for safety/persistence
interface DateTimeState {
  // A string representing the datetime in ISO 8601 format
  lastUpdated: string | null; 
  
  // Action to set the datetime
  setLastUpdated: (date: Date) => void; 
  
  // Action to retrieve the datetime as a Date object
  getLastUpdatedDate: () => Date | null; 

  // Internal cache for the Date object. Should not be used directly.
  _cachedLastUpdatedDate: Date | null;
}

const useDateTimeStore = create<DateTimeState>((set, get) => ({
  lastUpdated: null, // Initial state is null
  _cachedLastUpdatedDate: null, // Internal cache for the Date object

  setLastUpdated: (date: Date) => {
    const isoString = date.toISOString();
    set({ 
      lastUpdated: isoString,
      _cachedLastUpdatedDate: date // Cache the Date object directly
    });
  },
  
  getLastUpdatedDate: () => {
    const { _cachedLastUpdatedDate } = get();
    return _cachedLastUpdatedDate;
  }
}));

export default useDateTimeStore;
----

[,javascript,title="MyComponent.ts"]
----
import useDateTimeStore from "./useDateTimeStore";

function MyComponent() {
  // 1. Get the ISO string from the state (safer for persistence/memoization)
  const lastUpdatedString = useDateTimeStore(state => state.lastUpdated);

  // 2. Get the setter function
  const setLastUpdated = useDateTimeStore(state => state.setLastUpdated);

  // 3. Get the Date object for display/logic (calculated on-demand)
  const lastUpdatedDate = useDateTimeStore(state => state.getLastUpdatedDate());

  const handleUpdate = () => {
    // Set the current time by passing a new Date object
    setLastUpdated(new Date());
    console.log("Updated state with a new Date object.");
  };

  return (
    <div>
      <p>
        Stored ISO String (in Zustand):
        <strong>{lastUpdatedString || 'N/A'}</strong>
      </p>
      <p>
        Rendered Date (converted back):
        <strong>{lastUpdatedDate?.toUTCString() || 'N/A'}</strong>
      </p>
      <button onClick={handleUpdate}>
        Update Datetime
      </button>
    </div>
  );
}
----

== Explanations

[,Gemini]
____
Storing a **`Date`** object (which JavaScript uses for datetimes) in a **Zustand** store is straightforward, but it's crucial to consider how the state is handled, especially when dealing with **serialization** for persistence or transmission.

Here's the recommended approach:

*1. Store the Date as an ISO String*

The **safest and most common practice** is to store the `Date` object as an **ISO 8601 string** (e.g., `'2025-10-15T10:25:28.000Z'`) in your Zustand state.

  * **Why?** JavaScript's built-in `JSON.stringify()` (used by persistence layers like `zustand/middleware/persist`) automatically converts `Date` objects to these strings. More importantly, when the state is rehydrated or transmitted, the string remains intact, avoiding potential issues with non-standard date formats or loss of timezone information.

*2. Convert on Read/Write*

You'll perform the conversion between the `Date` object (used in your application logic) and the `string` (stored in the state) at the boundaries of your store's set functions.

*Example Implementation*

[,javascript,title="useDateTimeStore.ts"]
----
import { create } from 'zustand';

// Define the state structure
// We store the datetime as a string for safety/persistence
interface DateTimeState {
  // A string representing the datetime in ISO 8601 format
  lastUpdated: string | null; 
  
  // Action to set the datetime
  setLastUpdated: (date: Date) => void; 
  
  // Action to retrieve the datetime as a Date object
  getLastUpdatedDate: () => Date | null; 
}

const useDateTimeStore = create<DateTimeState>((set, get) => ({
  lastUpdated: null, // Initial state is null

  setLastUpdated: (date: Date) => {
    // WRITE/SET: Convert the Date object to an ISO string
    set({ lastUpdated: date.toISOString() });
  },
  
  getLastUpdatedDate: () => {
    const { lastUpdated } = get();
    
    // READ/GET: Convert the ISO string back to a Date object
    if (lastUpdated) {
      return new Date(lastUpdated);
    }
    return null;
  }
}));

export default useDateTimeStore;
----

*Usage in a Component*

When you use the store in your application:

[,javascript,title="MyComponent.ts"]
----
import useDateTimeStore from './useDateTimeStore';

function MyComponent() {
  // 1. Get the ISO string from the state (safer for persistence/memoization)
  const lastUpdatedString = useDateTimeStore(state => state.lastUpdated);
  
  // 2. Get the setter function
  const setLastUpdated = useDateTimeStore(state => state.setLastUpdated);
  
  // 3. Get the Date object for display/logic (calculated on-demand)
  const lastUpdatedDate = useDateTimeStore(state => state.getLastUpdatedDate());

  const handleUpdate = () => {
    // Set the current time by passing a new Date object
    setLastUpdated(new Date()); 
    console.log("Updated state with a new Date object.");
  };

  return (
    <div>
      <p>
        Stored ISO String (in Zustand): 
        <strong>{lastUpdatedString || 'N/A'}</strong>
      </p>
      <p>
        Rendered Date (converted back): 
        <strong>{lastUpdatedDate?.toLocaleString() || 'N/A'}</strong>
      </p>
      <button onClick={handleUpdate}>
        Update Datetime
      </button>
    </div>
  );
}
----

This pattern ensures that the data stored and persisted is a reliable string format, while your application logic still works with the convenient `Date` object format.
____

== BUGFIX

....
The result of getSnapshot should be cached to avoid an infinite loop Stack: 
....

[comment]
--
NOTE: Works but too complicated

[,javascript,title="useDateTimeStore.ts"]
----
import { create } from 'zustand';

// We store the datetime as a string for safety/persistence
interface DateTimeState {
    // A string representing the datetime in ISO 8601 format
    lastUpdated: string | null;

    // Action to set the datetime
    setLastUpdated: (date: Date) => void;
}

const useDateTimeStore = create<DateTimeState>((set) => ({
    lastUpdated: null, // Initial state is null

    setLastUpdated: (date: Date) => {
        // WRITE/SET: Convert the Date object to an ISO string
        set({ lastUpdated: date.toISOString() });
    },
}));

export default useDateTimeStore;
----

[,javascript,title="MyComponent.ts"]
----
import useDateTimeStore from "@/stores/useDateTimeStore";

function MyComponent() {
  // 1. Get the ISO string from the state (safer for persistence/memoization)
  const lastUpdatedString = useDateTimeStore(state => state.lastUpdated);

  // 2. Get the setter function
  const setLastUpdated = useDateTimeStore(state => state.setLastUpdated);

  // 3. Create a memoized Date object for display/logic
  const lastUpdatedDate = useMemo(() => {
    return lastUpdatedString ? new Date(lastUpdatedString) : null;
  }, [lastUpdatedString]);

  const handleUpdate = () => {
    // Set the current time by passing a new Date object
    setLastUpdated(new Date());
    console.log("Updated state with a new Date object.");
  };

  return (
    <div>
      <p>
        Stored ISO String (in Zustand):
        <strong>{lastUpdatedString || 'N/A'}</strong>
      </p>
      <p>
        Rendered Date (converted back):
        <strong>{lastUpdatedDate?.toLocaleString() || 'N/A'}</strong>
      </p>
      <button onClick={handleUpdate}>
        Update Datetime
      </button>
    </div>
  );
}
----
--

[,javascript,title="useDateTimeStore.ts"]
----
import { create } from 'zustand';

// We store the datetime as a string for safety/persistence
interface DateTimeState {
  // A string representing the datetime in ISO 8601 format
  lastUpdated: string | null;
  
  // Action to set the datetime
  setLastUpdated: (date: Date) => void;
  
  // Action to retrieve the datetime as a Date object
  getLastUpdatedDate: () => Date | null;

  // Internal cache for the Date object. Should not be used directly.
  _cachedLastUpdatedDate: Date | null;
}

const useDateTimeStore = create<DateTimeState>((set, get) => ({
  lastUpdated: null, // Initial state is null
  _cachedLastUpdatedDate: null, // Internal cache for the Date object

  setLastUpdated: (date: Date) => {
    const isoString = date.toISOString();
    set({
      lastUpdated: isoString,
      _cachedLastUpdatedDate: date // Cache the Date object directly
    });
  },
  
  getLastUpdatedDate: () => {
    const { _cachedLastUpdatedDate } = get();
    return _cachedLastUpdatedDate;
  }
}));

export default useDateTimeStore;
----

Replace 

[,javascript,title="MyComponent.ts"]
----
<strong>{lastUpdatedDate?.toLocaleString() || 'N/A'}</strong>
----

by

[,javascript,title="MyComponent.ts"]
----
<strong>{lastUpdatedDate?.toUTCString() || 'N/A'}</strong>
----